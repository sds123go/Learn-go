# 包和文件
&emsp;Go语言中包的作用即其他语言中的第三方库或模块，支模块化、封装编译隔离和重用，一般需要将第三方库放到设置的GOPATH路径下。每个包里有若干.go文件，代码中需要导出的标识符要以大写字母开头，类似其他语言中的public变量。

## 包的初始化
&emsp;包的初始化是从初始化包级别的变量开始，这些变量按照声明顺序初始化，如果包由多个.go文件组成，初始化按照编译器收到文件的顺序进行（go工具会在调用编译器前将go文件进行排序）

&emsp;包的初始化按照在程序中导入的顺序来进行，依赖顺序优先，每次初始化一个包。因此，如果包P导入了包Q，可以确保Q在P之前已完全初始化。初始化过程是自下向上，main包最后初始化。

# 并发

&emsp;并发可分为宏观并发和微观并发，宏观主要指用户体验上，程序并行执行；微观并发指多个计划任务按顺序执行，在CPU上快速切换。

&emsp;常见并发编程技术
>1 进程并发

进程是指运行起来的程序，需要占用系统资源。进程可分成5个状态，即初始态、就绪态、运行态、挂起态、结束态。就绪态是等待CPU分配时间片；运行状态占用CPU的状态；挂起态即阻塞状态，等待其他进程释放CPU。

>2 线程并发
线程属于轻量级的进程，Linux中其本质是进程，线程是最小的执行单元。

>3 同步

线程同步是指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回，同时其他线程为保证数据的一致性，不能调用该功能。因此对共享资源的访问需要加锁。

>4 协程并发 coroutine 也叫轻量级线程，python多使用协程。


# Go并发
&emsp;go语言从**语言层面上就支持并行**，且提供了自动垃圾回收机制，其内置的上层API基于顺序通信进程模型CSP，这意味着显式锁是可以避免的，因为Go通过相对安全的通道发送和接受数据以实现同步，这大大地简化了并发程序的编写。Go语言中的并发程序主要使用goroutine和channel实现。
## goroutine
&emsp;goroutine是Go语言并行设计的核心，又称为go程。goroutine其实就是协程，他比线程更小，十几个goroutine体现在底层就是五六个线程，go语言内部实现了go程之间的内存共享，执行goroutine只需极少的栈内存（大概4~5kb），在同时运行成千上万个并发任务时，goroutine比thread更易用、更高效、更轻便。

&emsp;只需在函数调用前添加 go 关键字就可创建并发执行单元

&emsp;runtime.Gosched()出让当前go程所占的CPU时间片，让出当前的goroutinez执行权限，调度器安排其他等待的任务运行，并在下次再次获得CPU时间轮片的时候，从该出让CPU的位置恢复执行。

&emsp;


