# 指针进阶

&emsp;指针是一个代表着某个内存地址的值，go语言对与指针的应用同C++相比，可操作空间较小，但保留了基本的内存操作，避免了C/C++中对指针的滥用而造成的安全和可靠性问题。*p又叫解引用、间接引用。内存空间布局图如下所示
![](..\..\..\Picture\01-栈帧内存存储.png)

&emsp;栈帧是用来给函数运行提供内存空间，取内存于 stack区域上。当发生函数调用时，就会产生栈帧。函数调用结束，释放栈帧。	栈帧存储：1. 局部变量。2. 形参。（形参与局部变量存储地位等同） 3. 内存字段描述值。其中内存字段描述值是存储的栈顶指针和栈基指针地址值。

&emsp;空指针是未被初始化的的指针，使用时会报错；野指针是指被一片无效的内存地址初始化的指针。

&emsp;变量存储时，赋值符号左边的变量表示变量所指向的内存空间；赋值符号右边的变量代表内存空间存储的数据值。

&emsp;使用new()函数是在堆内存上申请内存空间，当函数调用结束后，栈帧会消失，但在堆上的内存没有消失，因此用指针可以实现函数传参，传递引用。

&emsp;&emsp;堆内存内存空间较大，一般以GB为单位，而栈内存内存较小一般以Mb为单位。

# 切片
&emsp;由于数组容量固定，不能自动拓展，而且在作为函数参数进行传递时，是采用值传递的方式，将整个数组值拷贝一份给形参，因此，需要使用切片。在Go语言中几乎可以在所有场景中使用切片来代替数组。切片并不是数组或者数组指针，它是通过内部指针和相关属性引用数组片段，以实现变长方案。

&emsp;切片的常见创建方法
>1 自动推导类型&emsp;slice := []int{1,2,3,4}
>2 slice := make([]int,长度,容量)
>3 slice :=make([]int,长度)，该方法教常用

&emsp;如果切片是采用截取数组的方式来初始化，没有指定容量的情况下，切片的容量跟随数组或原切片。

&emsp;切片做函数参数是传引用

&emsp;append()函数，用于向切片中添加元素，append(切片对象，待追加元素)，当向切片追加元素时切片的容量会自动增长。

&emsp;copy()函数，用于复制切片，copy(目标位置切片，源切片)，对应位置复制。函数返回值为int类型

# Map
&emsp;字典或称映射，在一个map里的所有键都是唯一的，而且必须是支持==和！=操作符的类型，切片、函数以及包含切片的结构类型由于具有引用语义，不能作为映射的键。但是map的值可以是任意类型，所有键的数据类型必须是相同的，值也是，但键和值的类型可以不相同。map()不能使用cap()

&emsp;创建map的方式如下
>1 var m1 map[int]string  ---不能存储数据
>2 m2:=map[int]string{}  ---可以存储数据默认为0
>3 m3:=make(map[int]string)  ---默认长度为0
>4 m4:=make(map[int]string,10)  ---指定长度

&emsp;遍历map,使用for语句.for k,v :=range xx{}
&emsp;map[下标] 运算返回值有两个,第一个表示value的值,如果value不存在,返回nil;第二个值表示key是否存在的bool类型,若存在返回值为true,否则返回false.

&emsp;map的delete()函数,第一个参数为map类型,第二个参数为map中的key.

# 结构体
&emsp;结构体作为函数参数是值传递,在实际应用中几乎不会用到,内存消耗较大.

&emsp;结构体变量的地址和结构体首个元素的地址是一样的.

&emsp;结构体指针做函数的返回值,不可以返回局部变量的地址值,局部变量保存在栈帧上,函数调用已经结束,栈帧释放,局部变量的地址值不受保护,随时可被替代.
